package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"strconv"

	"github.com/heather92115/translator/graph/model"
	"github.com/heather92115/translator/internal/convert"
	"github.com/heather92115/translator/internal/srv"
)

// CreateVocab is the resolver for the createVocab field.
func (r *mutationResolver) CreateVocab(ctx context.Context, input model.NewVocab) (*model.Vocab, error) {
	incoming, err := convert.VocabFromNewGql(&input)
	if err != nil {
		return nil, err
	}

	vocabService, err := srv.NewVocabService()
	if err != nil {
		return nil, err
	}

	err = vocabService.CreateVocab(incoming)
	if err != nil {
		return nil, err
	}

	outgoing, err := convert.VocabToGql(incoming)
	if err != nil {
		return nil, err
	}

	return outgoing, nil
}

// UpdateVocab is the resolver for the updateVocab field.
func (r *mutationResolver) UpdateVocab(ctx context.Context, input model.UpdateVocab) (*model.Vocab, error) {
	incoming, err := convert.VocabFromGql(&input)
	if err != nil {
		return nil, err
	}

	vocabService, err := srv.NewVocabService()
	if err != nil {
		return nil, err
	}

	updated, err := vocabService.UpdateVocab(incoming)
	if err != nil {
		return nil, err
	}

	outgoing, err := convert.VocabToGql(updated)
	if err != nil {
		return nil, err
	}

	return outgoing, nil
}

// Vocab is the resolver for the vocab field.
func (r *queryResolver) Vocab(ctx context.Context, id *string) (*model.Vocab, error) {
	primaryId, err := strconv.Atoi(*id)
	if err != nil {
		return nil, fmt.Errorf("invalid id %s", *id)
	}

	vocabService, err := srv.NewVocabService()
	if err != nil {
		return nil, err
	}

	interim, err := vocabService.FindVocabByID(primaryId)
	if err != nil {
		return nil, err
	}

	return convert.VocabToGql(interim)
}

// Vocabs is the resolver for the vocabs field.
func (r *queryResolver) Vocabs(ctx context.Context, learningCode string, hasFirst bool, limit int) ([]*model.Vocab, error) {
	vocabService, err := srv.NewVocabService()
	if err != nil {
		return nil, err
	}

	list, err := vocabService.FindVocabs(learningCode, hasFirst, limit)
	if err != nil {
		return nil, err
	}

	return convert.VocabsToGql(list)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
