package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"strconv"

	"github.com/heather92115/verdure-admin/graph/model"
	"github.com/heather92115/verdure-admin/internal/convert"
	"github.com/heather92115/verdure-admin/internal/srv"
)

// CreateVocab is the resolver for the createVocab field.
func (r *mutationResolver) CreateVocab(ctx context.Context, input model.NewVocab) (*model.Vocab, error) {
	incoming, err := convert.VocabFromNewGql(&input)
	if err != nil {
		return nil, err
	}

	vocabService, err := srv.NewVocabService()
	if err != nil {
		return nil, err
	}

	err = vocabService.CreateVocab(incoming)
	if err != nil {
		return nil, err
	}

	outgoing, err := convert.VocabToGql(incoming)
	if err != nil {
		return nil, err
	}

	return outgoing, nil
}

// UpdateVocab is the resolver for the updateVocab field.
func (r *mutationResolver) UpdateVocab(ctx context.Context, input model.UpdateVocab) (*model.Vocab, error) {
	incoming, err := convert.VocabFromGql(&input)
	if err != nil {
		return nil, err
	}

	vocabService, err := srv.NewVocabService()
	if err != nil {
		return nil, err
	}

	updated, err := vocabService.UpdateVocab(incoming)
	if err != nil {
		return nil, err
	}

	outgoing, err := convert.VocabToGql(updated)
	if err != nil {
		return nil, err
	}

	return outgoing, nil
}

// CreateFixit is the resolver for the createFixit field.
func (r *mutationResolver) CreateFixit(ctx context.Context, input model.NewFixit) (*model.Fixit, error) {
	incoming, err := convert.NewFixitFromGql(&input)
	if err != nil {
		return nil, err
	}

	fixitService, err := srv.NewFixitService()
	if err != nil {
		return nil, err
	}

	err = fixitService.CreateFixit(incoming)
	if err != nil {
		return nil, err
	}

	outgoing, err := convert.FixitToGql(incoming)
	if err != nil {
		return nil, err
	}

	return outgoing, nil
}

// UpdateFixit is the resolver for the updateFixit field.
func (r *mutationResolver) UpdateFixit(ctx context.Context, input model.UpdateFixit) (*model.Fixit, error) {
	incoming, err := convert.UpdateFixitFromGql(&input)
	if err != nil {
		return nil, err
	}

	fixitService, err := srv.NewFixitService()
	if err != nil {
		return nil, err
	}

	updated, err := fixitService.UpdateFixit(incoming)
	if err != nil {
		return nil, err
	}

	outgoing, err := convert.FixitToGql(updated)
	if err != nil {
		return nil, err
	}

	return outgoing, nil
}

// Vocab is the resolver for the vocab field.
func (r *queryResolver) Vocab(ctx context.Context, id *string) (*model.Vocab, error) {
	primaryID, err := strconv.Atoi(*id)
	if err != nil {
		return nil, fmt.Errorf("invalid id %s", *id)
	}

	vocabService, err := srv.NewVocabService()
	if err != nil {
		return nil, err
	}

	interim, err := vocabService.FindVocabByID(primaryID)
	if err != nil {
		return nil, err
	}

	return convert.VocabToGql(interim)
}

// Vocabs is the resolver for the vocabs field.
func (r *queryResolver) Vocabs(ctx context.Context, learningCode string, hasFirst bool, limit int) ([]*model.Vocab, error) {
	vocabService, err := srv.NewVocabService()
	if err != nil {
		return nil, err
	}

	list, err := vocabService.FindVocabs(learningCode, hasFirst, limit)
	if err != nil {
		return nil, err
	}

	return convert.VocabsToGql(list)
}

// Fixit is the resolver for the fixit field.
func (r *queryResolver) Fixit(ctx context.Context, id *string) (*model.Fixit, error) {
	primaryID, err := strconv.Atoi(*id)
	if err != nil {
		return nil, fmt.Errorf("invalid id %s", *id)
	}

	fixitService, err := srv.NewFixitService()
	if err != nil {
		return nil, err
	}

	interim, err := fixitService.FindFixitByID(primaryID)
	if err != nil {
		return nil, err
	}

	return convert.FixitToGql(interim)
}

// Fixits is the resolver for the fixits field.
func (r *queryResolver) Fixits(ctx context.Context, status model.Status, vocabID string, startTime string, endTime string, limit int) ([]*model.Fixit, error) {
	fixitService, err := srv.NewFixitService()
	if err != nil {
		return nil, err
	}

	fStatus, fVocabID, duration, err := convert.FixitsQueryMapper(status, vocabID, startTime, endTime)
	if err != nil {
		return nil, err
	}

	list, err := fixitService.FindFixits(fStatus, fVocabID, duration, limit)
	if err != nil {
		return nil, err
	}

	return convert.FixitsToGql(list)
}

// Audit is the resolver for the audit field.
func (r *queryResolver) Audit(ctx context.Context, id *string) (*model.Audit, error) {
	primaryID, err := strconv.Atoi(*id)
	if err != nil {
		return nil, fmt.Errorf("invalid id %s", *id)
	}

	auditService, err := srv.NewAuditService()
	if err != nil {
		return nil, err
	}

	interim, err := auditService.FindAuditByID(primaryID)
	if err != nil {
		return nil, err
	}

	return convert.AuditToGql(interim)
}

// Audits is the resolver for the audits field.
func (r *queryResolver) Audits(ctx context.Context, tableName string, objectID string, startTime string, endTime string, limit int) ([]*model.Audit, error) {
	auditService, err := srv.NewAuditService()
	if err != nil {
		return nil, err
	}

	aObjectID, duration, err := convert.AuditQueryMapper(objectID, startTime, endTime)
	if err != nil {
		return nil, err
	}

	list, err := auditService.FindAudits(tableName, aObjectID, duration, limit)
	if err != nil {
		return nil, err
	}

	return convert.AuditsToGql(list)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
